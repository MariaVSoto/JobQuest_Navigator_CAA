# 代码实现示例和最佳实践

## 1. 简历管理服务代码示例

### 1.1 简历上传视图

```python
# api/views/resume_views.py
from rest_framework import status
from rest_framework.parsers import MultiPartParser, FormParser
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated

from ..models import Resume, ResumeVersion
from ..serializers import ResumeSerializer, ResumeVersionSerializer
from ..services.s3_service import S3Service

class ResumeUploadView(APIView):
    parser_classes = (MultiPartParser, FormParser)
    permission_classes = [IsAuthenticated]

    def post(self, request, *args, **kwargs):
        file_obj = request.FILES.get("file")
        resume_name = request.data.get("name", file_obj.name if file_obj else "Untitled Resume")
        user_id = request.user.id  # 假设JWT中包含用户ID

        if not file_obj:
            return Response({"error": "File not provided"}, status=status.HTTP_400_BAD_REQUEST)

        # 创建简历
        resume = Resume.objects.create(name=resume_name, user_id=user_id)

        # 创建简历版本
        s3_service = S3Service()
        s3_key = f"resumes/{user_id}/{resume.id}/initial/{file_obj.name}"
        
        if not s3_service.upload_file(file_obj, s3_key):
            resume.delete() # 如果上传失败，回滚简历创建
            return Response({"error": "Failed to upload file to S3"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        resume_version = ResumeVersion.objects.create(
            resume=resume,
            file_path=s3_key,
            file_name=file_obj.name,
            file_size=file_obj.size,
            file_type=file_obj.content_type,
            comment="Initial version"
        )

        serializer = ResumeSerializer(resume)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
```

### 1.2 简历版本上传视图

```python
# api/views/resume_views.py
class ResumeVersionUploadView(APIView):
    parser_classes = (MultiPartParser, FormParser)
    permission_classes = [IsAuthenticated]

    def post(self, request, resume_id, *args, **kwargs):
        try:
            resume = Resume.objects.get(id=resume_id, user_id=request.user.id)
        except Resume.DoesNotExist:
            return Response({"error": "Resume not found"}, status=status.HTTP_404_NOT_FOUND)

        file_obj = request.FILES.get("file")
        comment = request.data.get("comment", "New version")

        if not file_obj:
            return Response({"error": "File not provided"}, status=status.HTTP_400_BAD_REQUEST)

        s3_service = S3Service()
        # 使用ResumeVersion的ID作为S3路径的一部分，确保唯一性
        new_version_id = uuid.uuid4()
        s3_key = f"resumes/{request.user.id}/{resume.id}/{new_version_id}/{file_obj.name}"

        if not s3_service.upload_file(file_obj, s3_key):
            return Response({"error": "Failed to upload file to S3"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        resume_version = ResumeVersion.objects.create(
            id=new_version_id, # 显式设置ID
            resume=resume,
            file_path=s3_key,
            file_name=file_obj.name,
            file_size=file_obj.size,
            file_type=file_obj.content_type,
            comment=comment
        )

        serializer = ResumeVersionSerializer(resume_version)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
```

### 1.3 文件下载视图

```python
# api/views/file_views.py
from django.http import HttpResponse
from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from ..models import ResumeVersion
from ..services.s3_service import S3Service

class FileDownloadView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request, file_id, *args, **kwargs):
        try:
            # 假设file_id是ResumeVersion的ID
            resume_version = ResumeVersion.objects.get(id=file_id, resume__user_id=request.user.id)
        except ResumeVersion.DoesNotExist:
            return Response({"error": "File not found or access denied"}, status=status.HTTP_404_NOT_FOUND)

        s3_service = S3Service()
        file_content = s3_service.download_file(resume_version.s3_key)

        if file_content is None:
            return Response({"error": "Failed to download file from S3"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        response = HttpResponse(file_content, content_type=resume_version.file_type)
        response["Content-Disposition"] = f"attachment; filename={resume_version.file_name}"
        return response
```

## 2. AI建议服务代码示例

### 2.1 获取AI建议视图

```python
# api/views/suggestion_views.py
from rest_framework import status
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated

from ..models import Suggestion
from ..serializers import SuggestionSerializer, SuggestionInputSerializer
from ..services.openai_service import OpenAIService
from ..services.resume_service import ResumeService # 与简历管理服务通信

class AISuggestionView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request, *args, **kwargs):
        input_serializer = SuggestionInputSerializer(data=request.data)
        if not input_serializer.is_valid():
            return Response(input_serializer.errors, status=status.HTTP_400_BAD_REQUEST)

        validated_data = input_serializer.validated_data
        resume_id = validated_data["resumeId"]
        job_description = validated_data["jobDescription"]
        user_id = request.user.id
        auth_token = request.auth # 获取JWT令牌

        # 1. 从简历管理服务获取简历文件内容
        resume_service = ResumeService()
        resume_data = resume_service.get_resume(resume_id, user_id, auth_token)
        if not resume_data or not resume_data.get("versions"):
            return Response({"error": "Resume not found or has no versions"}, status=status.HTTP_404_NOT_FOUND)
        
        # 假设我们使用最新的版本
        latest_version = resume_data["versions"][0]
        file_id = latest_version["id"] # 假设版本ID就是文件ID
        
        resume_file_content = resume_service.get_resume_file(file_id, auth_token)
        if not resume_file_content:
            return Response({"error": "Failed to fetch resume file"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
        # 假设简历文件是文本可读的 (例如 .txt, .md, 或者从PDF/DOCX提取文本)
        # 这里需要一个辅助函数来从不同格式的简历文件中提取文本
        # from .utils import extract_text_from_resume
        # resume_text = extract_text_from_resume(resume_file_content, latest_version["file_type"])
        # 简化示例，假设是纯文本
        try:
            resume_text = resume_file_content.decode("utf-8")
        except UnicodeDecodeError:
            return Response({"error": "Could not decode resume file content. Ensure it is UTF-8 encoded text or implement proper text extraction."}, status=status.HTTP_400_BAD_REQUEST)

        # 2. 调用OpenAI服务进行分析
        openai_service = OpenAIService()
        analysis_result = openai_service.analyze_resume_job_match(resume_text, job_description)

        # 3. 保存建议
        suggestion = Suggestion.objects.create(
            user_id=user_id,
            resume_id=resume_id,
            job_description=job_description,
            score=analysis_result["score"],
            feedback=analysis_result["feedback"]
        )

        serializer = SuggestionSerializer(suggestion)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
```

## 3. Django最佳实践

### 3.1 项目结构

- **应用分离**：将项目划分为多个独立的Django应用，每个应用负责特定的功能模块。
- **配置管理**：使用环境变量管理敏感配置（如API密钥、数据库凭证），避免硬编码。
- **设置分离**：为不同环境（开发、测试、生产）创建不同的设置文件。

### 3.2 模型设计

- **原子性**：模型应该具有原子性，每个模型代表一个独立的实体。
- **规范化**：遵循数据库规范化原则，减少数据冗余。
- **索引**：为经常查询的字段创建索引，提高查询性能。
- **管理器**：使用自定义模型管理器封装复杂的查询逻辑。

### 3.3 视图设计

- **类视图**：优先使用Django REST Framework的类视图（APIView、GenericAPIView、ViewSet）。
- **序列化器**：使用序列化器处理数据的序列化和反序列化，以及数据验证。
- **权限控制**：使用DRF的权限类控制API访问权限。
- **版本控制**：为API提供版本控制，确保向后兼容性。

### 3.4 URL设计

- **RESTful**：遵循RESTful API设计原则，使用名词表示资源，使用HTTP方法表示操作。
- **一致性**：保持URL结构的一致性。
- **命名空间**：使用URL命名空间避免URL名称冲突。

### 3.5 测试

- **单元测试**：为每个模型、视图和工具函数编写单元测试。
- **集成测试**：测试组件之间的交互。
- **测试覆盖率**：使用`coverage.py`工具监控测试覆盖率，目标是达到80%以上。
- **测试数据**：使用`factory_boy`等工具生成测试数据。

### 3.6 性能优化

- **数据库查询**：使用`select_related`和`prefetch_related`优化数据库查询。
- **缓存**：使用Django的缓存框架缓存频繁访问的数据。
- **异步任务**：使用Celery等工具处理耗时的异步任务。
- **代码分析**：使用`django-debug-toolbar`和`django-silk`分析性能瓶颈。

## 4. 微服务开发最佳实践

### 4.1 服务独立性

- **独立部署**：每个微服务可以独立部署和扩展。
- **独立数据库**：每个微服务拥有自己的数据库，避免跨服务数据库访问。
- **松耦合**：服务之间通过定义良好的API进行通信，减少耦合。

### 4.2 API设计

- **契约优先**：先定义API契约（如OpenAPI规范），再进行服务实现。
- **幂等性**：确保POST、PUT、DELETE等操作具有幂等性。
- **错误处理**：定义统一的错误码和错误信息格式。

### 4.3 服务间通信

- **同步通信**：使用RESTful API进行同步通信。
- **异步通信**：使用消息队列（如RabbitMQ、Kafka）进行异步通信。
- **服务发现**：使用Consul或Etcd等工具进行服务发现。
- **断路器**：使用Hystrix等断路器模式处理服务调用失败。

### 4.4 配置管理

- **集中配置**：使用Spring Cloud Config或Consul等工具集中管理微服务配置。
- **动态配置**：支持配置的动态更新，无需重启服务。

### 4.5 日志和监控

- **集中日志**：使用ELK或EFK等工具集中管理微服务日志。
- **分布式追踪**：使用Zipkin或Jaeger等工具进行分布式追踪。
- **监控告警**：使用Prometheus和Grafana等工具监控微服务性能和健康状况，并设置告警。

## 5. 安全最佳实践

### 5.1 输入验证

- **严格验证**：对所有用户输入进行严格验证，防止XSS、SQL注入等攻击。
- **序列化器验证**：使用DRF序列化器进行数据验证。

### 5.2 认证和授权

- **JWT认证**：使用JWT进行无状态认证。
- **HTTPS**：所有API通信使用HTTPS加密。
- **权限控制**：基于角色的访问控制（RBAC）。

### 5.3 依赖管理

- **定期更新**：定期更新第三方库，修复已知的安全漏洞。
- **漏洞扫描**：使用`safety`或`pip-audit`等工具扫描依赖库的安全漏洞。

### 5.4 敏感数据保护

- **加密存储**：对敏感数据（如密码、API密钥）进行加密存储。
- **环境变量**：使用环境变量管理敏感配置。
- **日志脱敏**：避免在日志中记录敏感信息。

### 5.5 Docker安全

- **最小镜像**：使用官方的最小基础镜像。
- **非root用户**：在容器中以非root用户运行应用。
- **镜像扫描**：使用Clair或Trivy等工具扫描Docker镜像的安全漏洞。

## 6. 总结

本文档提供了一些基于Django框架的微服务开发的代码实现示例和最佳实践。遵循这些实践可以帮助开发团队构建高质量、可维护、可扩展和安全的微服务系统。

主要内容包括：

1. 简历管理服务的代码示例，包括简历上传、版本上传和文件下载视图。
2. AI建议服务的代码示例，包括获取AI建议视图。
3. Django开发最佳实践，包括项目结构、模型设计、视图设计、URL设计、测试和性能优化。
4. 微服务开发最佳实践，包括服务独立性、API设计、服务间通信、配置管理以及日志和监控。
5. 安全最佳实践，包括输入验证、认证和授权、依赖管理、敏感数据保护和Docker安全。

在实际开发过程中，应根据具体需求和场景选择合适的实践，并持续学习和改进。

